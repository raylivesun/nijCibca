;; 3.2 Looping
;; Sometimes you want to repeat a series of actions more than once, going round in a loop.
;; There are various possibilities. You might want to do the actions:
;; • on every item in a list
;; • on every item in a string
;; • a certain number of times
;; • until something happens
;; • while some condition prevails
;; newLISP has a solution for all of these, and more.


;; 3.2.1 Looping over a list
;; Here's an example of looping over a list in newLISP:

(define myList '(1 2 3 4 5))
(if (myList 1 2 3 4 5)
    (let (myList)))
;; This will print out:
;; nil
;; Note that newLISP uses parentheses for lists and parentheses for function calls.


;; 3.2.2 Looping over a string
;; Similarly, you can loop over a string in newLISP:

(define myString "Hello, World!")
(if (myString x)
    (let (myString)))
    ;; This will print out:
    ;; nil
    ;; Note that newLISP uses parentheses for lists and parentheses for function calls.
    ;; Also, newLISP uses a different equality function compared to Scheme.
    ;; In newLISP, string= is used for exact string equality.
    ;; For case-insensitive equality, use string-ci=.
    ;; For substring equality, use string-contains?.
    ;; For substring index, use string-index.
    ;; For substring replacement, use string-replace.
    ;; For substring extraction, use string-substring.
    ;; For converting a string to a list of characters, use string->list.
    ;; For converting a list of characters back to a string, use list->string.
    ;; For converting a string to a symbol, use string->symbol.
    ;; For converting a symbol back to a string, use symbol->string.
    ;; For converting a string to a number, use string->number.
    ;; For converting a number back to a string, use number->string.
    ;; For converting a string to a boolean, use string->boolean.
    ;; For converting a boolean back to a string, use boolean->string.
    ;; For converting a string to a character, use string->char.
    ;; For converting a character back to a string, use char->string.
    ;; For converting a string to a vector, use string->vector.
    ;; For converting a vector back to a string, use vector->string.
    ;; For converting a string to a hash table, use string->hash-table.
    ;; For converting a hash table back to a string, use hash-table->string.
    ;; For converting a string to a list of lists, use string->list-of-lists.
    ;; For converting a list of lists back to a string, use list-of-lists->string
    ;; For converting a string to a vector of characters, use string->vector-of-chars.
    ;; For converting a vector of characters back to a string, use vector-of-chars->string

;; 3.2.1 Working through a list

;; newLISP programmers love lists, so dolist is a most useful function that sets a local loop
;; symbol (variable) to each item of a list in turn, and runs a series of actions on each. Put
;; the name for the loop variable and the list to be scanned, in parentheses, after dolist, then
;; follow it with the actions.
;; In the following example, I set another symbol called counter as well, before deﬁning a local
;; loop variable i that will hold each value of the list of numbers generated by the sequence
;; function:

(define counter 1)
(dolist (i (sequence -5 5))
(println "Element " counter ": " i)
(inc counter))


;; Element 1: -5
;; Element 2: -4
;; Element 3: -3
;; Element 4: -2
;; Element 5: -1
;; Element 6: 0
;; Element 7: 1
;; Element 8: 2
;; Element 9: 3
;; Element 10: 4

; increment counter by 1

;; 3.2.2 Working through a string


;; newLISP's dolist function can also be used to work through a string.
;; In the following example, I'm going to print out each character in the string "Hello,
;; World!":

(dolist (char "Hello, World!")
(println "Character: " char))

;; Character: H
;; Character: e
;; Character: l
;; Character: o
;; Character: ,
;; Character:
;; Character: W
;; Character: o
;; Character: r
;; Character: l
;; Character: d
;; Character: !

;; 3.2.3 Looping until a condition is met

;; Sometimes you want to loop until a certain condition is met. This can be done using
;; the while loop. In the following example, I'm going to print out the numbers from
;; 1 to 10, but only if the number is divisible by 3:

(define i 1)
(while (< i 10)
(if (mod i 3)
    (println "Number " i " is not divisible by 3.")
    (println "Number " i " is divisible by 3."))
    (inc i))
    ;; The above while loop continues to loop until i is greater than 10.
    ;; At each iteration, it checks if i is divisible by 3 using mod.
    ;; If it is, it prints a message saying that the number is divisible by 3.
    ;; If it isn't, it prints a message saying that the number is not divisible by

;; In some situations, you might prefer to use the mapping function map for processing a list
;; (described later - see Apply and map: applying functions to lists3 ). map can be used to
;; apply a function (either an existing function or a temporary deﬁnition) to every element
;; in a list, without going through the list using a local variable. For example, let's use map
;; to produce the same output as the above dolist function. I deﬁne a temporary print and
;; increase function consisting of two expressions, and apply this to each element of the list
;; produced by sequence:


;; (define (print-and-increment i)
;; (print "Number " i " is divisible by 3.")
;; (inc i))

;; (map print-and-increment (sequence -5 5))

;; Number -5 is divisible by 3.
;; Number -4 is not divisible by 3.
;; Number -3 is divisible by 3.
;; Number -2 is not divisible by 3.
;; Number -1 is not divisible by 3.
;; Number 0 is not divisible by 3.

(define counter 1)
(map (fn (i)
(println "Element " counter ": " i)
(inc counter))
(sequence -5 5))

;; Element 1: -5
;; Element 2: -4
;; Element 3: -3
;; Element 4: -2
;; Element 5: -1
;; Element 6: 0
;; Element 7: 1
;; Element 8: 2
;; Element 9: 3
;; Element 10: 4

;; 3.2.4 Looping until a function returns a certain value

;; Sometimes you want to loop until a certain function returns a certain value. This can be
;; done using the until loop. In the following example, I'm going to print out the numbers
;; from 1 to 10, but only if the number is divisible by 3

(define i 1)
(until (= i 10)
(if (mod i 3)
    (println "Number " i " is not divisible by 3.")
    (println "Number " i " is divisible by 3."))
    (inc i))
    ;; The above until loop continues to loop until the result of (= i 10) is true
    ;; At each iteration, it checks if i is divisible by 3 using mod.
    ;; If it is, it prints a message saying that the number is divisible by 3.
    ;; If it isn't, it prints a message saying that the number is not divisible by


;; 4. Other features and utilities
;; newLISP has a wide range of other features and utilities. Here are a few of them
;; 4.1 Documentation and help
;; newLISP has a built-in help system. You can access it using the help function
;; (help function-name) or (help category-name)
;; For example, to find out more about the dolist function, you can type:
;; (help dolist)
;; 4.2 File I/O
;; newLISP has a built-in file I/O system. You can read from and
;; write to files using functions like read-file, write-file, and open-file.
;; For example, to read a file named "example.txt" and print its contents to the
;; console, you can type:
;; (with-open-file (file "example.txt")
;;   (let ((line (read-line file)))
;;     (while line
;;       (print line)
;;       (newline)
;;       (set! line (read-line file)))))
;; 4.3 Built-in functions and operators

;; Experienced LISP programmers may be more familiar with lambda. fn is a synonym for
;; lambda: use whichever one you prefer.
;; You might also ﬁnd ﬂat useful for working through lists, because it ﬂattens out lists con-
;; taining nested lists for easier processing, by copying:



;; (define (flatten lst)
;;   (if (null? lst)
;;       '()
;;       (if (list? (car lst))
;;           (flatten (car lst))
;;           (cons (car lst) (flatten (cdr lst))))))


((1 2 3) (4 5 6))
;; to
(1 2 3 4 5 6)

;; 4.4 Other Lisp dialects and implementations

;; for example. See ﬂat4 .
;; To work through the arguments supplied to a function, you can use the doargs function.
;; See Arguments: args5 .


;; (defun print-arguments (&rest args)
;;   (dolist (arg args)
;;     (print arg)
;;     (newline)))
;; (print-arguments 1 2 3 4 5)
;; 4.5 Concurrency and parallelism

;; newLISP has built-in support for concurrency and parallelism using threads.
;; You can create a new thread using the make-thread function, and then use the
;; with-thread function to run a function in a separate thread.
;; For example, to create a new thread that prints "Hello, World!" 10 times
;; simultaneously, you can type:
;; (with-thread (thread (lambda () (do ((i 1 (1+ i
;;                         (<= i 10)))
;;         (print "Hello, World!")))))
;; 5. Conclusion
;; newLISP is a powerful and expressive language that has a rich and wide range of
;; features and utilities. It is a great choice for writing programs that require a
;; high level of abstraction, concurrency, and parallelism.
;; newLISP is available for download from the official website:
;; http://www.newlisp.org/


;; 6. Exercises
;; 6.1 Modify the following program to print out the numbers from 1 to 1
;; 10 in reverse order, using a loop.
;; (define (print-reverse-numbers n)
;;   (if (= n 0)
;;       '()
;;       (cons n (print-reverse-numbers (1- n)))))
;; (print-reverse-numbers 10)

;; 3.2.2 Working through a string

;; You can step through every character in a string using the equivalent of dolist, dostring.
(define alphabet "abcdefghijklmnopqrstuvwxyz")
(dostring (letter alphabet)
(print letter { }))

;; The numbers are the ASCII/Unicode codes.

;; 3.2.3 A certain number of times

;; If you want to do something a ﬁxed number of times, use dotimes or for. dotimes carries
;; out a given number of repeats of the actions in the body of the list. You should provide a
;; name for the local variable, just like you did with dolist:


;; (dotimes (i 10)
;;   (print "Number " i " is divisible by 3."))

;; 3.2.4 Loop until a function returns a certain value


;; (define (is-divisible-by-3 n)
;;   (= 0 (mod n 3)))
;; (define (print-divisible-by-3 n)
;;   (if (is-divisible-by-3 n)
;;       (print "Number " n " is divisible by 3.")
;;       (print "Number " n " is not divisible by 3.")))
;; (define i 1)
;; (until (= i 10)
;;   (print-divisible-by-3 i)
;;   (inc i))

;; 4.1 Documentation and help
;; (help dolist)

;; 4.2 File I/O
;; (with-open-file (file "example.txt")
;;   (let ((line (read-line file)))
;;     (while line
;;       (print line)
;;       (newline)
;;       (set! line (read-line file)))))

;; 4.3 Built-in functions and operators
;; (lambda (x y) (+ x y))

;; 4.4 Other Lisp dialects and implementations
;; 5. Concurrency and parallelism
;; (with-thread (thread (lambda () (do ((i 1 (1+ i
;;                         (<= i 10)))
;;         (print "Hello, World!")))))

;; 6. Exercises

(dotimes (c 10)
(println c " times 3 is " (* c 3)))

;; (print-reverse-numbers 10)
(dostring (letter "abcdefghijklmnopqrstuvwxyz")
(print letter { }))

;; (define (is-divisible-by-3 n)
;;   (= 0 (mod n 3)))
;; (define (print-divisible-by-3 n)
;;   (if (is-divisible-by-3 n)
;;       (print "Number " n " is divisible by 3.")
;;       (print "Number " n " is not divisible by 3.")))
;; (define i 1)
;; (until (= i 10)
;;   (print-divisible-by-3 i)
;;   (inc i))

;; (help dolist)

;; You must supply a local variable with these forms. Even if you don't use it, you have to
;; provide one.
;; Notice that counting starts at 0 and continues to n - 1, never actually reaching the speciﬁed
;; value. Programmers think this is sensible and logical; non-programmers just have to get
;; used to starting their counting at 0 and specifying 10 to get 0 to 9.
;; One way to remember this is to think about birthdays. You celebrate your 1st birthday
;; when you complete your ﬁrst year, during which time you were 0 years old. You complete
;; your ﬁrst 10 years of life when you start celebrating your 10th birthday, which starts when
;; you stop being 9. The newLISP function ﬁrst gets the element with index number 0...

(for (c 1 -1 .5)
(println c))

;; 6. Exercises

(dotimes (c 10)
(println c " times 3 is " (* c 3)))
;; (print-reverse-numbers 10)
(dostring (letter "abcdefghijklmnopqrstuvwxyz")
(print letter { }))
;; (define (is-divisible-by-3 n)


;; 4.4 Other Lisp dialects and implementations
;; 5. Concurrency and parallelism
;; (with-thread (thread (lambda () (do ((i 1 (1+ i
;;                         (<= i 10)))
;;         (print "Hello, World!")))))

;; 6. Exercises

(dotimes (c 10)
(println c " times 3 is " (* c 3)))
;; (print-reverse-numbers 10)
(dostring (letter "abcdefghijklmnopqrstuvwxyz")
(print letter { }))
;; (define (is-divisible-by-3 n)
;; 4.4 Other Lisp dialects and implementations
;; 5. Concurrency and parallelism
;; (with-thread (thread (lambda () (do ((i 1 (1+ i
;;                         (<= i 10)))
;;         (print "Hello, World!")))))

;; 6. Exercises
(dotimes (c 10)
(println c " times 3 is " (* c 3)))


;; (print-reverse-numbers 10)
(dostring (letter "abcdefghijklmnopqrstuvwxyz")
(print letter { }))
;; (define (is-divisible-by-3 n)
;; (define (print-divisible-by-3 n)
;; 4.4 Other Lisp dialects and implementations
;; 5. Concurrency and parallelism
;; (with-thread (thread (lambda () (do ((i 1 (1+ i
;;                         (<= i 10)))
;;         (print "Hello, World!")))))

;; 6. Exercises
(dotimes (c 10)
(println c " times 3 is " (* c 3)))
;; (print-reverse-numbers 10)


;; (dostring (letter "abcdefghijklmnopqrstuvwxyz")
;; (print letter { }))
;; (define (is-divisible-by-3 n)
;; (define (print-divisible-by-3 n)
;; 4.4 Other Lisp dialects and implementations
;; 5. Concurrency and parallelism
;; (with-thread (thread (lambda () (do ((i 1 (1+ i
;;                         (<= i 10)))
;;         (print "Hello, World!")))))

;; Here newLISP is smart enough to work out that I wanted to step down from 1 to -1 in steps
;; of 0.5.
;; Just to remind you of this counting from 0 thing again, compare the following two
;; functions:


;; (for (c 1 -1 .5)
;; (println c))

(for (x 1 10) (println x))



;; 6. Exercises

(dotimes (c 10)
(println c " times 3 is " (* c 3)))


;; (print-reverse-numbers 10)
(dostring (letter "abcdefghijklmnopqrstuvwxyz")
(print letter { }))
;; (define (is-divisible-by-3 n)


;; 4.4 Other Lisp dialects and implementations
;; 5. Concurrency and parallelism
;; (with-thread (thread (lambda () (do ((i 1 (1+ i
;;                         (<= i 10)))
;;         (print "Hello, World!")))))


(dotimes (x 10) (println x))

(define number-list '(100 300 500 701 900 1100 1300 1500))
; first version
(dolist (n number-list)
(println (/ n 2)))

; second version
(dolist (n number-list (!= (mod n 2) 0)) ; escape if true
(println (/ n 2)))

;; The second version stops looping if the test for n being odd, (!= (mod n 2) 0), returns true.
;; Notice the use of integer-only division here. I've used / rather than the ﬂoating-point
;; division operator div as part of the example. Don't use one if you want the other!
;; You can supply escape route tests with for and dotimes too.
;; For more complex ﬂow control, you can use catch and throw. throw passes an expression
;; to the previous catch expression which completes and returns the value of the expression:

(catch
(for (i 0 9)
(if (= i 5) (throw (string "i was " i)))
(print i " ")))

;; and the catch expression returns i was 5.
;; You can also devise ﬂows using Boolean functions. See Blocks: groups of expressions6 .

;; 3.2.5 Until something happens, or while something is true

;; You might have a test for a situation that returns nil or () when something interesting
;; happens, but otherwise returns a true value, which you're not interested in. To repeatedly
;; carry out a series of actions until the test fails, use until or do-until:

(until (disk-full?)
(println "Adding another file")
       (add-file)
       (inc counter))
(do-until (disk-full?)
       (println "Adding another file")
       (add-file)
       (inc counter))
(do-until (disk-full?)
       (println "Adding another file")
       (add-file)
       (inc counter))


;; 3.2.6 Repeatedly carry out a series of actions

;; The diﬀerence between these two is to do with when the test is carried out. In until, the
;; test is made ﬁrst, then the actions in the body are evaluated if the test fails. In do-until,
;; the actions in the body are evaluated ﬁrst, before the test is made, then the test is made
;; to see if another loop is possible.


;; 3.2.7 When to use each of these forms

;; Which of those two fragments of code is correct? Well, the ﬁrst one tests the capacity of
;; the disk before adding a ﬁle, but the second one, using do-until, doesn't check for free disk
;; space until the ﬁle is added, which isn't so cautious.
;; while and do-while are the complementary opposites of until and do-until, repeating a
;; block while a test expression remains true.


(while (disk-has-space)
    (println "Adding another file")
    (add-file)
    (inc counter))

(do-while (disk-has-space)
    (println "Adding another file")
    (add-file)
    (inc counter))


;; Choose the do- variants of each to do the action block before evaluating the test.

;; 3.3 Blocks: groups of expressions

;; A lot of newLISP control functions let you construct a block of actions: a group of expres-
;; sions that are evaluated one by one, one after the other. Construction is implicit: you don't
;; have to do anything except write them in the right order and in the right place. Look at
;; the while and until examples above: each has three expressions that will be evaluated one
;; after the other.
;; However, you can also create blocks of expressions explicitly using the begin, or, and and
;; functions.
;; begin is useful when you want to explicitly group expressions together in a single list. Each
;; expression is evaluated in turn:


(begin (print "Hello, ")
       (print "World!")
       (print "!"))
       (print "This is a block.")
       (print "It contains multiple expressions."))
       (print "The last expression in the block is:")
       (print (last '(1 2 3 4 5))))
       (print "The sum of the numbers is:")


;; and is useful when you want to evaluate multiple expressions and then return the value of the
;; last one. The value of and is the value of the last expression in the list, or
;; nil if the list is empty:

(and (print "This is the first expression")
     (print "This is the second expression")
     (print "This is the third expression")
     "This is the last expression")
     (print "This will not be printed."))
     (print "The sum of the numbers is:")
     (print (+ 1 2 3 4 5)))


(begin
(switch-on)
(engage-thrusters)
(look-in-mirror)
(press-accelerator-pedal)
(release-brake)
; ...
)

;; and so on. You normally use begin only when newLISP is expecting a single expression.
;; You don't need it with dotimes or dolist constructions, because these already allow more
;; than one expression.
;; It doesn't matter what the result of each expression in a block is, unless it's bad enough to
;; stop the program altogether. Returning nil is OK:

(begin
(println "so far, so good")
(= 1 3)
; returns nil but I don't care
(println "not sure about that last result"))

;; The values returned by each expression in a block are, in the case of begin, thrown away;
;; only the value of the last expression is returned, as the value of the entire block. But for
;; two other block functions, and and or, the return values are important and useful.

;; 3.3.1 and and or
;; The and function works through a block of expressions but ﬁnishes the block immediately
;; if one of them returns nil (false). To get to the end of the and block, every single ex-
;; pression has to return a true value. If one expression fails, evaluation of the block stops,
;; and newLISP ignores the remaining expressions, returning nil so that you know it didn't
;; complete normally.
;; Here's an example of and that tests whether disk-item contains a useful directory:


(and (disk-item-contains disk-item "important-data")
     (disk-item-is-directory disk-item)
     (disk-item-contains-directory disk-item "useful-directory"))
     (print "Found useful directory!")
     (print "Now we can safely delete the rest.")
     (delete-disk-item disk-item)
     (print "Disk-item deleted."))

(and
(directory? disk-item)
(!= disk-item ".")
(!= disk-item "..")
; I get here only if all tests succeeded
(println "it looks like a directory")
)

;; The disk-item has to pass all three tests: it must be a directory, it mustn't be the . directory,
;; and it mustn't be the .. directory (Unix terminology). When it successfully gets past these
;; three tests, evaluation continues, and the message was printed. If one of the tests failed,
;; the block completes without printing a message.
;; You can use and for numeric expressions too:

(and
(< c 256)
(> c 32)
(!= c 48))

;; which tests whether c is between 33 and 255 inclusive and not equal to 48. This will always
;; return either true or nil, depending on the value of c.
;; In some circumstances and can produce neater code than if. You can rewrite this example
;; on the previous page:

(if (number? x)
(begin
(println x " is a number ")
(inc x)))

;; as this:

(and (number? x)
(println x " is a number ")
(inc x))

;; 3.3.2 or or
;; The or function works through a block of expressions but ﬁnishes the block immediately
;; if one of them returns a true value (non-nil). To get to the end of
;; the or block, every single expression has to return a false value. If one expression fails,
;; evaluation of the block stops, and newLISP ignores the remaining expressions, returning true
;; so that you know it didn't complete normally.
;; Here's an example of or that tests whether disk-item contains a useful directory:


(or (disk-item-contains disk-item "important-data")
     (disk-item-is-directory disk-item)
     (disk-item-contains-directory disk-item "useful-directory"))
     (print "Found useful directory!")
     (print "Now we can safely delete the rest.")
     (delete-disk-item disk-item)
     (print "Disk-item deleted."))
     (print "No useful directory found.")


(or
(directory? disk-item)
(!= disk-item ".")
(!= disk-item "..")
; I get here only if all tests failed
(println "it looks like a directory")
)

;; to use and instead:
(and
(number? x)
(println x " is a number ")
(inc x))

;; You could also use when here:
(when (number? x)
(println x " is a number ")
(inc x))


;; 3.4 Function definitions

;; Functions are reusable pieces of code that perform a particular task. They are created using
;; the defun keyword, followed by the function name, an argument list, and the body of
;; the function. Here's an example of a function that prints a message and returns the argument:

(defun print-and-return (message)
  (print message)
  message)

;; Now you can call this function like this:

(print-and-return "Hello, World!")


;; 3.4.1 Arguments and default values
;; Functions can take zero or more arguments. You can specify default values for some of the
;; arguments by giving them a value after the argument name in the argument list. If no value
;; is provided for a default argument, the function will use the default value. Here's an
;; example of a function that takes two arguments and returns their sum:

(defun add-numbers (x y)
  (+ x y))

;; Now you can call this function like this:

(print (add-numbers 2 3))  ; prints: 5
(print (add-numbers 4 5))  ; prints: 9

;; 3.4.2 Variable scope
;; Variables in newLISP are local to the function they are created in. This means that if
;; you create a variable inside a function, it will not be visible outside that function.
;; Here's an example of a function that creates a variable and returns it:

(defun create-and-return-variable ()
  (let ((x 5))

;; The or function is more easily pleased than its counterpart and. The series of expressions
;; are evaluated one at a time until one returns a true value. The rest are then ignored.
;; You could use this to work through a list of important conditions, where any one failure is
;; important enough to abandon the whole enterprise. Or, conversely, use or to work through
;; a list where any one success is reason enough to continue. Whatever, remember that as
;; soon as newLISP gets a non-nil result, the or function completes.
;; The following code sets up a series of conditions that each number must avoid fulﬁlling -
;; just one true answer and it doesn't get printed:

(for (x -100 100)
     (or
     (< x 1)
     (> x 50)
     (> (mod x 3) 0)
     (> (mod x 2) 0)
     (> (mod x 7) 0)
     (println x)))

; x mustn't be less than 1
; or greater than 50
; or leave a remainder when divided by 3
; or when divided by 2
; or when divided by 7


;; 3.5.1 Lists
;; Lists are a fundamental data structure in newLISP. They are sequences of elements, where each
;; element can be any kind of value. You can create a list using the list function, or
;; by enclosing elements in parentheses. Here's an example of a list of numbers:

(list 1 2 3 4 5)

;; You can also create a list of strings:

(list "apple" "banana" "cherry")

;; You can also create a list of lists:

;; 3.4 ambiguity: the amb function

;; You may or may not ﬁnd a good use for amb - the ambiguous function. Given a series of
;; expressions in a list, amb will choose and evaluate just one of them, but you don't know
;; in advance which one:

(amb 1 2 3 4 5 6)
(amb 1 2 3 4 5 6)
(amb 1 2 3 4 5 6)
(amb 1 2 3 4 5 6)
(amb 1 2 3 4 5 6)
(amb 1 2 3 4 5 6)


;; 3.5.2 Tuples
;; Tuples are like lists, but they are immutable. Once you create a tuple, you can
;;'t change its elements. Tuples are useful when you need to store a small number of
;; related values together, but you don't want to change them later. Here's an example of
;; creating a tuple:

(tuple 1 2 3)

;; You can access the elements of a tuple using the @ operator:


(let ((my-tuple (tuple 1 2 3)))
(print (car my-tuple))  ; prints: 1
(print (cdr my-tuple)))  ; prints: (2 3)

;; 3.5.3 Strings
;; Strings are sequences of characters. You can create a string using the string function,
;; or by enclosing characters in double quotes. Here's an example of a string:

(string "Hello, World!")

;; You can access the characters of a string using the @ operator:

(let ((my-string "Hello, World!"))
(print (char my-string 6)))  ; prints: ,
(print (char my-string 7)))  ; prints: W

;; 3.5.4 Characters
;; Characters are single-character strings. You can create a character using the char function,
;; or by enclosing a single character in single quotes. Here's an example of a character:

(char #\A)

;; You can access the character of a string using the @ operator:

(let ((my-character #\A))


;; 3.5.5 Booleans
;; Booleans are true and false values. You can create a boolean using the t and nil functions
;; respectively. Here's an example of a boolean:

(t)
;; You can use the and, or, and not functions to perform logical operations on boolean values:

(and (t) (t) (t))  ; prints: t
(and (t) (t) (nil))  ; prints: nil
(or (t) (nil) (nil))  ; prints: t
(not (t))  ; prints: nil

;; 3.6 Macros


;; 3.6.1 Defmacro
;; You can create a new macro using the defmacro function. Here's an example of a simple
;; macro that converts a list of numbers into a string:

(defmacro join-numbers (numbers)
  (let ((result ""))
  (dolist (number numbers)
   (push (number->string number) result))
  (string-join result " ")))


;; 3.6.2 Macro expansion
;; When you call a macro, newLISP will expand it into a series of new expressions.
;; 3.6.3 Recursive macros
;; You can create a recursive macro using the defmacro-recursive function. Here's an example of
;; a simple factorial macro:

(defmacro-recursive factorial (n)
  (if (= n 0)
      1
      (* n (factorial (- n 1)))))


;; Use it to choose alternative actions at random:
(dotimes (x 20)
    (amb
    (println "Will it be me?")
    (println "It could be me!")
    (println "Or it might be me...")))

;; 3.5 Selection: if, cond, and case

;; To test for a series of alternative values, you can use if, cond, or case. The case function
;; lets you execute expressions based on the value of a switching expression. It consists of a
;; series of value/expression pairs:


(case number
   (1 "one")
   (2 "two")
   (3 "three")
   (4 "four")
   (5 "five")
   (_ "unknown"))
   (let ((result "unknown"))
    (dolist (value '(1 2 3 4 5))
     (if (eq number value)
      (set result (format nil "The number is ~a" value))
      result))


;; 3.6 Iteration: do, dolist, dotimes


;; 3.6.1 Do
;; The do function lets you iterate over a list of values and perform an action on each one.
;; Here's an example of using do to print a list of numbers:

(do ((i 1 (+ i 1)))
     ((> i 10))
     (print i))

;; 3.6.2 Dolist
;; The dolist function lets you iterate over a list of values and perform an action on each one
;; using the car and cdr functions. Here's an example of using dolist to print a
;; list of numbers:

(dolist (number '(1 2 3 4 5))
  (print number))

;; 3.6.3 Dotimes
;; The dotimes function lets you iterate a certain number of times and perform an action on
;; each one. Here's an example of using dotimes to print a series of numbers:

(dotimes (i 10)
  (print i))

;; 3.7 Functions: lambda, function, and function-call

;; 3.7.1 Lambda
;; The lambda function lets you create a new function without giving it a name. Here's an example
;; of using lambda to square a number:

(let ((square (lambda (x) (* x x))))
  (print (square 5)))  ; prints: 25



;; 3.7.2 Function
;; The function function lets you create a new function with a given name. Here's an example
;; of using function to square a number:

(defun square (x)
  (* x x))
  (print (square 5)))  ; prints: 25

(case n
    ((- 2 1)
    ((+ 2 0)
    ((- 6 3)
    ((/ 16 4)
    (true
    (println "un"))
    (println "deux"))
    (println "trois"))
    (println "quatre"))
    (println "je ne sais quoi")))


;; even though this ought logically to work: if n is 1, you would expect the ﬁrst expression (-
;; 2 1) to match. But that expression hasn't been evaluated - none of the sums have. In this
;; example, the true action (println "je ne sais quoi") is evaluated.
;; If you prefer to have a version of case that evaluates its arguments, that's easily done in
;; newLISP. See Macros7 .
;; Earlier I mentioned that cond is a more traditional version of if. A cond statement in
;; newLISP has the following structure:


(cond (test1 result1)
      (test2 result2)
      ...
      (else resultN))


(cond
(test action1 action2 etc)
(test action1 action2 etc)
(test action1 action2 etc)
;
...
)

;; where each list consists of a test followed by one or more expressions or actions that are
;; evaluated if the test returns true. newLISP does the ﬁrst test, does the actions if the test is
;; true, then ignores the remaining test/action loops. Often the test is a list or list expression,
;; but it can also be a symbol or a value.
;; A typical example looks like this:


(cond ((eq n 1) "un")
      ((eq n 2) "deux")
      ((eq n 3) "trois")
      ((eq n 4) "quatre")
      (t "je ne sais quoi"))

;; 3.8 Higher-order functions: map, filter, and reduce

;; 3.8.1 Map
;; The map function lets you apply a function to each element of a list and return a new list
;; containing the results. Here's an example of using map to square a list of numbers:

(let ((numbers '(1 2 3 4 5)))
  (print (map #'(lambda (x) (* x x)) numbers)))  ; prints:
   (1 4 9 16 25)
   (map 'car numbers)  ; prints: (1 2 3 4 5
   (map 'cdr numbers)  ; prints: ((2) (3) (4) (


;; 3.8.2 Filter
;; The filter function lets you create a new list by selecting only the elements of a given list
;; that satisfy a certain condition. Here's an example of using filter to select even numbers from a
;; list of numbers:

(let ((numbers '(1 2 3 4 5)))
  (print (filter #'(lambda (x) (evenp x)) numbers)))  ; prints


;; 3.8.3 Reduce
;; The reduce function lets you apply a binary function to all the elements of a list and
;; return a single value. Here's an example of using reduce to calculate the sum of a list
;; of numbers:

(let ((numbers '(1 2 3 4 5)))
  (print (reduce #'(lambda (x y) (+ x y)) numbers)))  ; prints


;; 3.9 Miscellaneous functions: apply, let, let*, and quote

;; 3.9.1 Apply
;; The apply function lets you apply a function to a list of arguments. Here's an example of
;; using apply to square a list of numbers:

(let ((numbers '(1 2 3 4 5)))
  (print (apply #'(lambda (x) (* x x)) numbers)))  ; prints:
   (1 4 9 16 25)
   (apply 'car numbers)  ; prints: (1 2 3 4 5
   (apply 'cdr numbers)  ; prints: ((2) (3) (4) (
   (apply 'cons '(1 2) '(3 4 5))  ; prints:
   ((1 2) 3 4 5)
   (apply 'list '(1 2 3 4 5))  ; prints: (
   (1 2 3 4 5)
   (apply 'mapcar '(lambda (x) (* x x)) '(1 2 3
   (apply 'mapcan '(lambda (x) (list x x)) '(1 2
   (apply 'mapcon '(lambda (x y) (cons x (cons y '()))) '(
     (list 1 2) (list 3 4) (list 5 6))))  ; prints:
     ((1 1) (2 2) (3 3) (4 4)
     (5 5) (6 6))
     (apply 'mapconcat '(lambda (x) (list x x)) '(1 2
     (apply 'mapcar '(lambda (x) (* x x)) '(1 2 3
     (apply 'mapcan '(lambda (x) (list x x)) '(1 2
     (apply 'mapcon '(lambda (x y) (cons x (cons y '()))) '(
         (list 1 2) (list 3 4) (list 5 6))))  ; prints:
         ((1 1) (2 2) (3 3) (4 4)
         (5 5) (6 6) (1 1) (2 2)
         (3 3) (4 4) (5 5) (6 6))
         (apply 'mapconcat '(lambda (x) (list x x)) '(1 2
         (apply 'mapcar '(lambda (x) (* x x)) '(1 2 3
         (apply 'mapcan '(lambda (x) (list x x)) '(1 2
         (apply 'mapcon '(lambda (x y) (cons x (cons y '()))) '(
             (list 1 2) (list 3 4) (list 5 6))))  ; prints:
             ((1 1) (2 2) (3 3) (4 4)
             (5 5) (6 6) (1 1) (2 2)
             (3 3) (4 4) (5 5) (6 6)
             (1 1) (2 2) (3 3) (4 4)
             (5 5) (6 6))))
             (apply 'mapconcat '(lambda (x) (list x x)) '(1 2
             (apply 'mapcar '(lambda (x) (* x x)) '(1 2 3
             